#include <iostream.h>
#include <conio.h>
#include <stdlib.h>
#include <dos.h>

signed const char WIDTH = 39;   // ширина поля stoLbiki(x)
signed const char HEIGHT = 24;  // высота поля stroki(y)

signed char botX = WIDTH / 2;       // позиция бота по X-stolbik
signed char botY = HEIGHT / 2;      // позиция бота по Y-stroka
signed char foodX=8, foodY=5;           // позиция еды


// отрисовка поля=============================================
void draw() {
  _setcursortype(0);
    clrscr();  // очистка экрана (можно убрать для оптимизации)
    for (signed char y = 0; y < HEIGHT; y++) {   //skaniryem prosmotr vsego poLya
	for (signed char x = 0; x < WIDTH; x++) {   //kak po h tak i po w
            if (x == botX && y == botY) cout << '*';   // бот
	  else  if (x == foodX && y == foodY) cout << 'o';   // eda
	   else { cout << "."; }
        asm nop;
        }
        cout << "\r\n";         // перевод строки
      asm nop;     //cpu- optimizaciya
    }
}
//--------------------------------------------------------------------------------------------------------------------------------------

// логика движения бота к еде (примитивно)=======================
void moveBot() {
    signed char vision = 2; // расстояние, на котором бот видит еду

    // Проверяем: находится ли еда в квадрате зрения вокруг бота
    if (foodX >= botX - vision && foodX <= botX + vision &&
        foodY >= botY - vision && foodY <= botY + vision) {

        // Еда видна — двигаемся к ней
        if (botX < foodX) botX++;
        else if (botX > foodX) botX--;

        if (botY < foodY) botY++;
        else if (botY > foodY) botY--;

    } else {
        // Еда не видна — двигаемся случайно, чтобы искать
        signed char dir = rand() % 4; // 0-вверх, 1-вниз, 2-влево, 3-вправо
        switch (dir) {
            case 0: botY--; break;
            case 1: botY++; break;
            case 2: botX--; break;
            case 3: botX++; break;
        }

        // Не выходим за границы поля
        if (botX < 0) botX = 0;
        if (botY < 0) botY = 0;
        if (botX >= WIDTH) botX = WIDTH - 1;
        if (botY >= HEIGHT) botY = HEIGHT - 1;
    }

    // Проверка — дошёл ли бот до еды
    if (botX == foodX && botY == foodY) {
        delay(900); // пауза — бот "ест"
        foodX = rand() % WIDTH;  // новая еда
        foodY = rand() % HEIGHT;
    }
}
//---------------------------------------------------------------------------------------------------------------------------------------


int main() {
    randomize();

    while (!kbhit()) {
        draw();        // отрисовка поля
        moveBot();     // бот движется
	delay(150);     // скорости обновления(уменьши для быстродействия)
      asm nop;
    }

    getch();  // ждем нажатия клавиши перед выходом
    
    return 0;
}



